<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>interpolate_main: cvp_ce Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">interpolate_main
   </div>
   <div id="projectbrief">PLANER Honours project 2020 - Ground Plane Removal</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cvp_ce Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab01ec866d7352423868c92256099a93e"><td class="memItemLeft" align="right" valign="top"><a id="ab01ec866d7352423868c92256099a93e"></a>
typedef std::vector&lt; std::pair&lt; cv::Point2i, cv::Point2i &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>curvePatch</b></td></tr>
<tr class="separator:ab01ec866d7352423868c92256099a93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2f7e3603ca020f13c8cee162c45321c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecvp__ce.html#a2f7e3603ca020f13c8cee162c45321c6">findVoids</a> (const cv::Mat &amp;grid, const double noValue, curvePatch &amp;u_curve, curvePatch &amp;v_curve, curvePatch &amp;w_curve, curvePatch &amp;t_curve)</td></tr>
<tr class="memdesc:a2f7e3603ca020f13c8cee162c45321c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the begin and end vertices of every void in "grid", along every curve in each of 4 directions (<a class="el" href="namespacecvp__ce.html#DIRECTIONS">u</a>, <a class="el" href="namespacecvp__ce.html#DIRECTIONS">v</a>, <a class="el" href="namespacecvp__ce.html#DIRECTIONS">w</a>, <a class="el" href="namespacecvp__ce.html#DIRECTIONS">t</a>). Each vertex pair is stored in the corresponding direction_curvePatch.  <a href="#a2f7e3603ca020f13c8cee162c45321c6">More...</a><br /></td></tr>
<tr class="separator:a2f7e3603ca020f13c8cee162c45321c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4696f21a2858e3715631384bcb627c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecvp__ce.html#a7b4696f21a2858e3715631384bcb627c">hermiteSmooth</a> (cv::Mat &amp;grid, const double noValue, const cv::Point2i beg, const cv::Point2i end, const cv::Point2i direction)</td></tr>
<tr class="memdesc:a7b4696f21a2858e3715631384bcb627c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes user input "beg" and "end", which specify the start and end points of a line in the direction "direction". Cubic Hermite curves are used to estimate the values of collinear points between beg and end. These estimates are stored at the corresponding coordinate positions in "grid".  <a href="#a7b4696f21a2858e3715631384bcb627c">More...</a><br /></td></tr>
<tr class="separator:a7b4696f21a2858e3715631384bcb627c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0695d79d1333faa98819c5d9cb3e4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecvp__ce.html#a2c0695d79d1333faa98819c5d9cb3e4d">interpolate</a> (cv::Mat &amp;grid, const cv::Mat &amp;mask)</td></tr>
<tr class="memdesc:a2c0695d79d1333faa98819c5d9cb3e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will use the binary mask "mask" to determine which values in "grid" to estimate. These values will be estimated using Wecker at al.'s contextual void patching algorithm and the estimates will be stored in "grid".  <a href="#a2c0695d79d1333faa98819c5d9cb3e4d">More...</a><br /></td></tr>
<tr class="separator:a2c0695d79d1333faa98819c5d9cb3e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd><a href="#" onclick="location.href='mai'+'lto:'+'emr'+'ch'+'i00'+'1@'+'myu'+'ct'+'.ac'+'.z'+'a'; return false;">emrch<span style="display: none;">.nosp@m.</span>i001<span style="display: none;">.nosp@m.</span>@myuc<span style="display: none;">.nosp@m.</span>t.ac<span style="display: none;">.nosp@m.</span>.za</a> </dd></dl>
<dl class="section date"><dt>Date</dt><dd>August 2020</dd></dl>
<p>The functions in this namespace handle all manipulation of data required to perform the contextual void patching interpolation method.</p>
<p><a class="anchor" id="DIRECTIONS"></a>cv::Point2i <b>u</b>(0,1) &mdash; static variable representing 'u' direction vector <br />
 cv::Point2i <b>v</b>(1,0) &mdash; static variable representing 'v' direction vector <br />
 cv::Point2i <b>w</b>(-1,1) &mdash; static variable representing 'w' direction vector <br />
 cv::Point2i <b>t</b>(1,1) &mdash; static variable representing 't' direction vector <br />
 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2f7e3603ca020f13c8cee162c45321c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7e3603ca020f13c8cee162c45321c6">&#9670;&nbsp;</a></span>findVoids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvp_ce::findVoids </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>noValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">curvePatch &amp;&#160;</td>
          <td class="paramname"><em>u_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">curvePatch &amp;&#160;</td>
          <td class="paramname"><em>v_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">curvePatch &amp;&#160;</td>
          <td class="paramname"><em>w_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">curvePatch &amp;&#160;</td>
          <td class="paramname"><em>t_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds the begin and end vertices of every void in "grid", along every curve in each of 4 directions (<a class="el" href="namespacecvp__ce.html#DIRECTIONS">u</a>, <a class="el" href="namespacecvp__ce.html#DIRECTIONS">v</a>, <a class="el" href="namespacecvp__ce.html#DIRECTIONS">w</a>, <a class="el" href="namespacecvp__ce.html#DIRECTIONS">t</a>). Each vertex pair is stored in the corresponding direction_curvePatch. </p>
<p>CREDIT: <a href="#" onclick="location.href='mai'+'lto:'+'emr'+'ch'+'i00'+'1@'+'myu'+'ct'+'.ac'+'.z'+'a'; return false;">emrch<span style="display: none;">.nosp@m.</span>i001<span style="display: none;">.nosp@m.</span>@myuc<span style="display: none;">.nosp@m.</span>t.ac<span style="display: none;">.nosp@m.</span>.za</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>cv::Mat const reference &mdash; Matrix of values. </td></tr>
    <tr><td class="paramname">noValue</td><td>double const value &mdash; Missing points in "grid" have this value. </td></tr>
    <tr><td class="paramname">u_curve</td><td>curvePatch reference &mdash; A vector where start and end vertices will be stored along <a class="el" href="namespacecvp__ce.html#DIRECTIONS">u</a> direction. </td></tr>
    <tr><td class="paramname">v_curve</td><td>curvePatch reference &mdash; A vector where start and end vertices will be stored along <a class="el" href="namespacecvp__ce.html#DIRECTIONS">v</a> direction. </td></tr>
    <tr><td class="paramname">w_curve</td><td>curvePatch reference &mdash; A vector where start and end vertices will be stored along <a class="el" href="namespacecvp__ce.html#DIRECTIONS">w</a> direction. </td></tr>
    <tr><td class="paramname">t_curve</td><td>curvePatch reference &mdash; A vector where start and end vertices will be stored along <a class="el" href="namespacecvp__ce.html#DIRECTIONS">t</a> direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>CALLS TO: none</p>
<p>CALLED FROM: <a class="el" href="namespacecvp__ce.html#a2c0695d79d1333faa98819c5d9cb3e4d">interpolate</a></p>
<p>METHOD: The following is pseudocode describing how the function works.</p><ol type="1">
<li>Empty u_curve, v_curve, w_curve and t_curve vectors.</li>
<li>... </li>
</ol>

</div>
</div>
<a id="a7b4696f21a2858e3715631384bcb627c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4696f21a2858e3715631384bcb627c">&#9670;&nbsp;</a></span>hermiteSmooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvp_ce::hermiteSmooth </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>noValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Point2i&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Point2i&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Point2i&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes user input "beg" and "end", which specify the start and end points of a line in the direction "direction". Cubic Hermite curves are used to estimate the values of collinear points between beg and end. These estimates are stored at the corresponding coordinate positions in "grid". </p>
<p>CREDIT: <a href="#" onclick="location.href='mai'+'lto:'+'emr'+'ch'+'i00'+'1@'+'myu'+'ct'+'.ac'+'.z'+'a'; return false;">emrch<span style="display: none;">.nosp@m.</span>i001<span style="display: none;">.nosp@m.</span>@myuc<span style="display: none;">.nosp@m.</span>t.ac<span style="display: none;">.nosp@m.</span>.za</a>; Nils Pipenbrinck (1998), Hermite Curve Interpolation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>cv::Mat reference &mdash; Matrix of values. </td></tr>
    <tr><td class="paramname">noValue</td><td>double const value &mdash; Missing points in "grid" have this value. </td></tr>
    <tr><td class="paramname">beg</td><td>cv::Point2i const value &mdash; Point coordinates indicating position in "grid" to begin hermite curve interpolation. </td></tr>
    <tr><td class="paramname">end</td><td>cv::Point2i const value &mdash; Point coordinates indicating position in "grid" to end hermite curve interpolation. Must be collinear with "beg" in the positive direction of vector "direction". </td></tr>
    <tr><td class="paramname">direction</td><td>cv::Point2i const value &mdash; Vector coordinates of the direction of the curve. Treated as a unit vector i.e. all distances are scaled with its norm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>CALLS TO: none</p>
<p>CALLED FROM: <a class="el" href="namespacecvp__ce.html#a2c0695d79d1333faa98819c5d9cb3e4d">interpolate</a></p>
<p>METHOD: The following is pseudocode describing how the function works.</p><ol type="1">
<li>... </li>
</ol>

</div>
</div>
<a id="a2c0695d79d1333faa98819c5d9cb3e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0695d79d1333faa98819c5d9cb3e4d">&#9670;&nbsp;</a></span>interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvp_ce::interpolate </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will use the binary mask "mask" to determine which values in "grid" to estimate. These values will be estimated using Wecker at al.'s contextual void patching algorithm and the estimates will be stored in "grid". </p>
<p>CREDIT: <a href="#" onclick="location.href='mai'+'lto:'+'emr'+'ch'+'i00'+'1@'+'myu'+'ct'+'.ac'+'.z'+'a'; return false;">emrch<span style="display: none;">.nosp@m.</span>i001<span style="display: none;">.nosp@m.</span>@myuc<span style="display: none;">.nosp@m.</span>t.ac<span style="display: none;">.nosp@m.</span>.za</a>; Wecker et al. (2007), Contextual Void Patching for Digital Elevation Model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>cv::Mat reference &mdash; Matrix containing known points. </td></tr>
    <tr><td class="paramname">mask</td><td>cv::Mat const reference &mdash; Binary mask showing points to be interpolated. Must have the same dimensions as grid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>CALLS TO: findVoids, <a class="el" href="namespacecvp__ce.html#a7b4696f21a2858e3715631384bcb627c">hermiteSmooth</a></p>
<p>CALLED FROM: main</p>
<p>METHOD: The following is pseudocode describing how the function works.</p><ol type="1">
<li>Find start and end points of voids along all curves in the 4 <a class="el" href="namespacecvp__ce.html#DIRECTIONS">directions</a></li>
<li>Store the void coordinate pairs</li>
<li>At each void coordinate pair, build a hermite curve interpolated patch between the beginning and end points</li>
<li>Calculate the minimum distance to a known point for every missing point in "grid" in each <a class="el" href="namespacecvp__ce.html#DIRECTIONS">direction</a></li>
<li>For every missing point M: 5.1. calculate the sum of inverse distances <ul>
<li><code>invTotal</code> in all 4 <a class="el" href="namespacecvp__ce.html#DIRECTIONS">directions</a> 5.2. weight the hermite solution in each direction with the inverse minimum distance 5.3. add the 4 weighted hermite solutions 5.4. divide the weighted sum by </li>
<li><code>invTotal</code> and store the answer at M 6 end loop 7 return </li>
</ul>
</li>
</ol>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
