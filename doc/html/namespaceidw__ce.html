<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>interpolate_main: idw_ce Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">interpolate_main
   </div>
   <div id="projectbrief">PLANER Honours project 2020 - Ground Plane Removal</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">idw_ce Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae1c5ab8c0578cf0103125e97fe9b69e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceidw__ce.html#ae1c5ab8c0578cf0103125e97fe9b69e9">nearestNeighbour</a> (cv::Mat &amp;dataset, const double &amp;noValue, const double &amp;ignore)</td></tr>
<tr class="memdesc:ae1c5ab8c0578cf0103125e97fe9b69e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function estimates missing values in "dataset" by setting the value to the value of its nearest known neighbour. If there are multiple nearest neighbours, the average is taken and it stores the estimates in "dataset.  <a href="#ae1c5ab8c0578cf0103125e97fe9b69e9">More...</a><br /></td></tr>
<tr class="separator:ae1c5ab8c0578cf0103125e97fe9b69e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0353314a195777f8ab2baa3d1aa61dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceidw__ce.html#a0353314a195777f8ab2baa3d1aa61dcb">iterate</a> (cv::Mat &amp;dataset, const cv::Mat &amp;mask, const int blockRadius, const double &amp;noValue, const double &amp;ignore)</td></tr>
<tr class="memdesc:a0353314a195777f8ab2baa3d1aa61dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a single iteration over the Matrix "dataset" and estimates values for missing points&mdash;indicated by "mask"&mdash;using the local modified Shephard algorithm. <b>See</b> <a class="el" href="namespaceidw__ce.html#af1a4c1755f98b117f835169d021e5086">interpolate</a>.  <a href="#a0353314a195777f8ab2baa3d1aa61dcb">More...</a><br /></td></tr>
<tr class="separator:a0353314a195777f8ab2baa3d1aa61dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a4c1755f98b117f835169d021e5086"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceidw__ce.html#af1a4c1755f98b117f835169d021e5086">interpolate</a> (cv::Mat &amp;dataset, const cv::Mat &amp;mask, const int blockRadius, const double &amp;noValue, const double &amp;ignore)</td></tr>
<tr class="memdesc:af1a4c1755f98b117f835169d021e5086"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function estimates the values of "dataset" indicated by "mask" using an iterative version of local modified Shephard algorithm with the neighbourhood radius set to blockRadius.  <a href="#af1a4c1755f98b117f835169d021e5086">More...</a><br /></td></tr>
<tr class="separator:af1a4c1755f98b117f835169d021e5086"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd><a href="#" onclick="location.href='mai'+'lto:'+'emr'+'ch'+'i00'+'1@'+'myu'+'ct'+'.ac'+'.z'+'a'; return false;">emrch<span style="display: none;">.nosp@m.</span>i001<span style="display: none;">.nosp@m.</span>@myuc<span style="display: none;">.nosp@m.</span>t.ac<span style="display: none;">.nosp@m.</span>.za</a> </dd></dl>
<dl class="section date"><dt>Date</dt><dd>August 2020 <br />
</dd></dl>
<p>The functions in this namespace handle all manipulation of data required to perform inverse distance weighting interpolation method.</p>
<p><a class="anchor" id="THRESHOLD"></a>double <b>SURROUND_THRESHOLD</b> &mdash; with default value of 0.4 used to determine if there are enough neighbourhood points for estimation </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af1a4c1755f98b117f835169d021e5086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a4c1755f98b117f835169d021e5086">&#9670;&nbsp;</a></span>interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int idw_ce::interpolate </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>blockRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>noValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ignore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function estimates the values of "dataset" indicated by "mask" using an iterative version of local modified Shephard algorithm with the neighbourhood radius set to blockRadius. </p>
<p>CREDIT: <a href="#" onclick="location.href='mai'+'lto:'+'emr'+'ch'+'i00'+'1@'+'myu'+'ct'+'.ac'+'.z'+'a'; return false;">emrch<span style="display: none;">.nosp@m.</span>i001<span style="display: none;">.nosp@m.</span>@myuc<span style="display: none;">.nosp@m.</span>t.ac<span style="display: none;">.nosp@m.</span>.za</a>; Local Modified Shephard algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>cv::Mat reference &mdash; Matrix of values. </td></tr>
    <tr><td class="paramname">mask</td><td>cv::Mat const reference &mdash; Binary mask showing values to be estimated. Must have the same dimensions as "dataset". Every corresponding point in "dataset" to be estimated must have value "noValue". </td></tr>
    <tr><td class="paramname">blockRadius</td><td>int const value &mdash; Radius of grid points to use in estimation. </td></tr>
    <tr><td class="paramname">noValue</td><td>double const value &mdash; Missing points in "dataset" have this value. </td></tr>
    <tr><td class="paramname">ignore</td><td>double const value &mdash; Points with this value are not taken into account.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int value &mdash; returns the number of iterations.</dd></dl>
<p>CALLS TO: <a class="el" href="namespaceidw__ce.html#a0353314a195777f8ab2baa3d1aa61dcb">iterate</a></p>
<p>CALLED FROM: main</p>
<p>METHOD: The following is pseudocode describing how the function works.</p><ol type="1">
<li>while NumberOfMissingValues &gt; 0: call iterate</li>
<li>return NumberOfIterations </li>
</ol>

</div>
</div>
<a id="a0353314a195777f8ab2baa3d1aa61dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0353314a195777f8ab2baa3d1aa61dcb">&#9670;&nbsp;</a></span>iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idw_ce::iterate </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>blockRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>noValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ignore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a single iteration over the Matrix "dataset" and estimates values for missing points&mdash;indicated by "mask"&mdash;using the local modified Shephard algorithm. <b>See</b> <a class="el" href="namespaceidw__ce.html#af1a4c1755f98b117f835169d021e5086">interpolate</a>. </p>
<p>CREDIT: <a href="#" onclick="location.href='mai'+'lto:'+'emr'+'ch'+'i00'+'1@'+'myu'+'ct'+'.ac'+'.z'+'a'; return false;">emrch<span style="display: none;">.nosp@m.</span>i001<span style="display: none;">.nosp@m.</span>@myuc<span style="display: none;">.nosp@m.</span>t.ac<span style="display: none;">.nosp@m.</span>.za</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>cv::Mat reference &mdash; Matrix of values. </td></tr>
    <tr><td class="paramname">mask</td><td>cv::Mat const reference &mdash; Binary mask showing values to be estimated. Must have the same dimensions as "dataset". Every corresponding point in "dataset" to be estimated must have value "noValue". </td></tr>
    <tr><td class="paramname">blockRadius</td><td>int const value &mdash; Radius of grid points to use in estimation. </td></tr>
    <tr><td class="paramname">noValue</td><td>double const value &mdash; Missing points in "dataset" have this value. </td></tr>
    <tr><td class="paramname">ignore</td><td>double const value &mdash; Points with this value are not taken into account.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>CALLS TO: none</p>
<p>CALLED FROM: <a class="el" href="namespaceidw__ce.html#af1a4c1755f98b117f835169d021e5086">interpolate</a></p>
<p>METHOD: The following is pseudocode describing how the function works.</p><ol type="1">
<li>calculate filter Matrix of weights</li>
<li>For each missing value M: 2.1 extract subMatrix of size (2*blockRadius-1) by (2*blockRadius-1) centered at M from "dataset" 2.2 apply weights to subMatrix 2.3 sum values in the weighted Matrix 2.4 store sum at M 3 return </li>
</ol>

</div>
</div>
<a id="ae1c5ab8c0578cf0103125e97fe9b69e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c5ab8c0578cf0103125e97fe9b69e9">&#9670;&nbsp;</a></span>nearestNeighbour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void idw_ce::nearestNeighbour </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>noValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ignore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function estimates missing values in "dataset" by setting the value to the value of its nearest known neighbour. If there are multiple nearest neighbours, the average is taken and it stores the estimates in "dataset. </p>
<p>CREDIT: <a href="#" onclick="location.href='mai'+'lto:'+'emr'+'ch'+'i00'+'1@'+'myu'+'ct'+'.ac'+'.z'+'a'; return false;">emrch<span style="display: none;">.nosp@m.</span>i001<span style="display: none;">.nosp@m.</span>@myuc<span style="display: none;">.nosp@m.</span>t.ac<span style="display: none;">.nosp@m.</span>.za</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>cv::Mat reference &mdash; Matrix of values. </td></tr>
    <tr><td class="paramname">noValue</td><td>double const value &mdash; Missing points in "dataset" have this value. </td></tr>
    <tr><td class="paramname">ignore</td><td>double const value &mdash; Points with this value are not taken into account.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>CALLS TO: none</p>
<p>CALLED FROM: main</p>
<p>METHOD: The following is pseudocode describing how the function works.</p><ol type="1">
<li>For each missing point in "dataset": 1.1. radius := 1 1.2. begin loop until radius covers all of "dataset": 1.2.1. search for known points within radius in "dataset" 1.2.2. if numberOfKnownPoints == 0: radius++ 1.2.3. else: exit loop 1.3 Set value at missing point = averageOfFoundPointValues 2 return </li>
</ol>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
